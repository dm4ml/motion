# Sample Application

We'll be building a fashion search application, which will allow users to search for what clothes to buy based on a specific query. For our prototype, we'll use the following data sources (i.e., retailers):

* Everlane's catalog

A catalog is a collection of (image, description, link) tuples.

Then, our ML pipeline will be composed of the following components:

* Query to idea generation (text to text, ML)
* Idea to product retrieval (text to image, ML)

## Motion Framework

An application written in Motion relies on three abstractions:

* _Store_: A database used to store data, with methods to read and write values
* _Namespace_: A collection of data records in the store that has a predefined schema
* _Trigger_: A trigger is a stateful component of an ML pipeline, executed when a certain condition is met

### Stores and Namespaces

When creating an application in Motion, the first step is to create a store. To do this, run the following command:

```python
import motion

store = get_store("fashion", create=True, memory=False)
```

If `create` is set to `True`, then the store will be created if it doesn't already exist. If `memory` is set to `True`, then the store will be created in memory, and not persisted to disk. The example command creates the store "fashion" and persists it to disk.

The next step is to define the namespaces for the store. Typically, there will be a namespace for each entrypoint into the application. For example, in the fashion search application, we will have a namespace for the query, and a namespace for the image catalog. 

Each namespace in defined upfront with a schema, such as:

```python
import motion
from typing import TypeVar


class Retailer(motion.MEnum):
    NORDSTROM = "Nordstrom"
    REVOLVE = "Revolve"
    BLOOMINGDALES = "Bloomingdales"
    EVERLANE = "Everlane"


class QuerySource(motion.MEnum):
    OFFLINE = "Offline"
    ONLINE = "Online"


class QuerySchema(motion.Schema):
    src: QuerySource
    query_id: int
    query: str
    text_suggestion: str
    img_id: int
    img_score: float
    feedback: bool


class CatalogSchema(motion.Schema):
    retailer: Retailer
    img_url: str
    img_blob: TypeVar("BLOB")
    img_name: str
    permalink: str
    img_embedding: TypeVar("FLOAT[]")
```

You can think of each record in each namespace as having the attributes defined in the namespace's schema. Each schema must subclass `motion.Schema,` which gives it additional attributes `id` (unique integer key), `created_at` (timestamp), and `derived_id` (optional id the record was derived from, if the record is to be duplicated). Note that these attributes are automatically generated by the store, and do not need to be defined in the schema.

 Each schema must also provide types for each attribute or field. Types can be enums like `Retailer` and `QuerySource` above, primitive types like `str` and `int`, or DuckDB types wrapped in `TypeVar`, like `TypeVar("BLOB")` or `TypeVar("FLOAT[]")`. The latter two types are used to represent DuckDB's `BLOB` and `FLOAT[]` types, respectively. See the [DuckDB documentation](https://duckdb.org/docs/sql/data_types/overview.html) for more information on their types.

Finally, we add the namespaces with their corresponding schemas to the store:

```python
store.addNamespace("query", QuerySchema)
store.addNamespace("catalog", CatalogSchema)
```

### Triggers

A trigger is a stateful component of an ML pipeline, executed after `store.set` is called on a key that the trigger is listening to. Triggers are defined by subclassing `motion.Trigger`, and they have the following lifecycle:

1. `setUp`: Called when the trigger is first created (i.e., when the application is first run). Creates any necessary resources/state and returns a state dictionary object.

On every fire of the trigger, the following methods are called with the parameters `id` (id of the record that was set) and `triggered_by` ((namespace, key, value) NamedTuple), in this order:

2. `shouldInfer`: Returns `True` if `infer` should be run, and `False` otherwise.
3. `infer`: Called if `shouldInfer` returns `True`. 
4. `shouldFit`: Called after `infer` is run. Returns `True` if `fit` should be run, and `False` otherwise.
5. `fit`: Called if `shouldFit` returns `True`. Returns a state dictionary object with any updated state (if state doesn't update, the dictionary can be empty). In the future, this method will be run in a separate thread.

Each Trigger object has access to the store via `self.store` attribute and the ability to update state in certain lifecycle methods. Any lifecycle method is allowed to call `self.store.set` to update the store, potientially firing more triggers. **Only the `setUp` and `fit` methods return new state.** State should not be updated manually within lifecycle methods, as this will cause concurrency issues down the road. Additionally, state should only be updated via returning updated state for some keys in a dictionary in `setUp` and `fit`, not by directly updating the `self.state` attribute like `self.state["some_key"] = some_var`.

To recap, here is a table of lifecycle methods and acceptable write actions:

| Lifecycle Method | Acceptable Actions |
|------------------|--------------------|
| `setUp`          | Returning state, `self.store.set`    |
| `shouldInfer`    | `self.store.set`    |
| `infer`          | `self.store.set`    |
| `shouldFit`      | `self.store.set`    |
| `fit`            | Returning state, `self.store.set`    |

Finally, here is a simple example of a trigger that runs an LLM to suggest an outfit idea given a query:

```python
import motion

class SuggestIdea(motion.Trigger):
    def setUp(self):
        # Set up the query suggestion model
        return {"cohere": cohere.Client(os.environ["COHERE_API_KEY"])}

    def shouldFit(self, id, triggered_by):
        # Check if fit should be called
        return False

    def fit(self, id, triggered_by):
        # Fine-tune or fit the query suggestion model
        pass

    def shouldInfer(self, id, triggered_by):
        return True

    def infer(self, id, triggered_by):
        # Generate the query suggestions
        query = triggered_by.value
        prompt = (
            f"Give a detailed outfit ideas for a woman to wear to {query}."
        )
        response = self.state["cohere"].generate(
            prompt=prompt,
            model="command-xlarge-nightly",
            max_tokens=300,
            temperature=0.9,
            k=0,
            p=0.75,
            stop_sequences=[],
            return_likelihoods="NONE",
        )
    
        self.store.set(
            "query", identifier=identifier, key_values={"text_suggestion": response[0].text}
        )
```

And we add this trigger to fire when the `query` namespace's `query` key is set for some record:

```python
store.addTrigger(
    name="suggest_idea",
    keys=["query.query"],
    trigger=SuggestIdea,
)
```

Note that the `keys` parameter is a list of strings, where each string is of the form `namespace.key`. This means that the trigger will fire whenever the `key` key is set in the `namespace` namespace.

### Store API

The store API provides methods to read and write data to the store. The following methods are available:

* `store.addNamespace(name, schema)`: Adds a namespace to the store with the given name and schema
* `store.deleteNamespace(name)`: Deletes the namespace with the given name
* `store.addTrigger(name, keys, trigger)`: Adds a trigger to the store with the given name, keys (list of strings, where each string is of the form `namespace.key`), and trigger (subclass of `motion.Trigger` or function that accepts `id`, `triggered_by`, and `store` as parameters)
* `store.deleteTrigger(name)`: Deletes the trigger with the given name
* `store.getTriggersForKey(namespace, key)`: Returns a list of triggers that are listening to the given key in the given namespace
* `store.getTriggersForAllKeys`: Returns a list of triggers that are listening to all keys
* `store.getNewId(namespace)`: Returns a new unique id for the given namespace; useful for creating a new record in the namespace
* `store.set(namespace, id, key_values: dict, run_duplicate_triggers: bool = False)`: Sets the key-value pairs in `key_values` for the record with the given id in the given namespace. If `run_duplicate_triggers` is set to `True`, then if there is a duplicate trigger among the keys in `key_values`, then the duplicate trigger will be run.
* `store.duplicate(namespace, id)`: Duplicates the record with the given id in the given namespace, setting the `derived_from` attribute to be the given id. Returns the id of the new record. *Triggers are not run in duplicating a record's keys.*
* `store.get(namespace, id, keys, **kwargs)`: Returns a dictionary of key-value pairs for the given keys in the record with the given id in the given namespace. Optionally accepts `include_derived` as a parameter (default `False`), which determines whether to include values for records derived from the record with the given id. If `include_derived` is set to `True`, then a `pd.DataFrame` is returned.
* `store.mget(namespace, ids, keys, **kwargs)`: Returns a `pd.DataFrame` of key-value pairs for the given keys in the records with the given ids in the given namespace.
* `store.getIdsForKey(namespace, key, value)`: Returns a list of ids for records in the given namespace that have the given key-value pair. Equivalent to the SQL query `SELECT id FROM store_name.namespace WHERE key = value`, where `store_name` is the name of the store.
* `store.sql(stmt)`: Executes the given SQL statement on the store. Returns a `pd.DataFrame` if the statement is a `SELECT` statement, and `None` otherwise.


### Interesting Design Patterns

#### 1. Duplicating Records in Triggers

Sometimes you may want to duplicate records in a trigger. For example, if a user submits a query to the fashion search, you may want `SuggestIdea` to return 5 different outfit ideas instead of just one. In this case, you can duplicate the record in the `SuggestIdea` trigger, and then set the `text_suggestion` key for each of the 5 records. This is done by calling `self.store.duplicate` in the `SuggestIdea` trigger, and then calling `self.store.set` for each of the 5 records. The new `infer` method for `SuggestIdea` looks like this:

```python
def infer(self, id, triggered_by):
    # Generate the query suggestions
    query = triggered_by.value
    prompt = (
        f"List 5 detailed outfit ideas for a woman to wear to {query}."
    )
    response = self.state["cohere"].generate(
        prompt=prompt,
        model="command-xlarge-nightly",
        max_tokens=300,
        temperature=0.9,
        k=0,
        p=0.75,
        stop_sequences=[],
        return_likelihoods="NONE",
    )
    text = response[0].text
    suggestions = [s.strip() for s in text.split("\n")[:5]]
    suggestions = [re.sub("[1-9]. ", "", s) for s in suggestions]
    suggestions = [s for s in suggestions if s != ""]

    for s in suggestions:
        new_id = self.store.duplicate("query", id=id)
        self.store.set(
            "query", id=new_id, key_values={"text_suggestion": s}
        )
```

In the above code, if there were a trigger defined on the `text_suggestion` key, then it would be run for each of the 5 records.

#### 2. Using `shouldFit` and `shouldInfer` to Control When Triggers Run

Sometimes a trigger will be defined for multiple keys, where one key might be responsible for `fit` and another key might be responsible for `infer`. For example, suppose we have a retrieval trigger that matches a `text_suggestion` to nearest neighbor image embeddings. We might want to run the `fit` method of the trigger whenever a new image is added to the catalog, and we might want to run the `infer` method of the trigger whenever a new `text_suggestion` is added to the query namespace. It may look like this:

```python
class Retrieval(motion.Trigger):
    def setUp(self):
        pass

    def shouldFit(self, id, triggered_by):
        # Call fit on new images
        if (
            triggered_by.namespace == "catalog"
            and triggered_by.key == "img_blob"
        ):
            return True


        return False

    def fit(self, id, triggered_by):
        print("Fitting...")

    def shouldInfer(self, id, triggered_by):
        # Call infer only on text suggestions
        if triggered_by.key == "text_suggestion":
            return True

        return False

    def infer(self, id, triggered_by):
        print("Inferring...")

store.addTrigger(
    name="retrieval",
    keys=["query.text_suggestion", "catalog.img_blob"],
    trigger=Retrieval,
)
```

See `triggers.py` for a full example of this pattern, including finetuning on a `feedback` attribute.


#### 3. Entry Points to the Application

TODO(shreyashankar): document


#### 4. Querying the DB directly with SQL

TODO(shreyashankar): document