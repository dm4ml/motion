{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Welcome to Motion","text":"<p>Motion is a system for defining and incrementally maintaining self-updating prompts in Python.</p> <p>Alpha Release</p> <p>Motion is currently in alpha. We are actively working on improving the documentation and adding more features. If you are interested in using Motion and would like dedicated support from one of our team members, please reach out to us at shreyashankar@berkeley.edu.</p>"},{"location":"#why-self-updating-prompts","title":"Why Self-Updating Prompts?","text":"<p>LLM accuracy often significantly improves with more context. Consider an e-commerce focused LLM pipeline that recommends products to users. The recommendations might improve if the prompt considers the user's past purchases and browsing history. Ideally, any new information about the user (e.g., a new purchase or browsing event) should be incorporated into the LLM pipeline's prompts as soon as possible; thus, we call them self-updating prompts.</p>"},{"location":"#why-is-it-hard-to-use-self-updating-prompts","title":"Why is it Hard to Use Self-Updating Prompts?","text":"<p>Consider the e-commerce example above. The prompt might grow to be very long---so long that there's a bunch of redundant or event useless information in the prompt. So, we might want to summarize the user's past purchases and browsing history into a single prompt. However, summarizing the user's past purchases and browsing history every time we log a new purchase or browsing event, or whenever the user requests a new recommendation, can take too long and thus prohibitively increase end-to-end latency for getting a recommendation.</p> <p>In general, we may want to use LLMs or run some other expensive operation when incrementally processing new information, e.g., through summarization, extracting structured information, or generating new data. When there is a lot of information to process, the best LLMs can take upwards of 30 seconds. This can be unacceptable for production latency.</p>"},{"location":"#what-is-motion","title":"What is Motion?","text":"<p>As LLM pipeline developers, we want a few things when building and using self-updating prompts:</p> <ul> <li>Flexibility: We want to be able to define our sub-parts of prompts (e.g., summaries). We also want to be able to define our own logic for how to turn sub-parts into string prompts and self-updatingly update sub-parts.</li> <li>Availability: We want there to always be some version of prompt sub-parts available, even if they are a little stale. This way we can minimize end-to-end latency.</li> <li>Freshness: Prompts should incorporate as much of the latest information as possible. In the case where information arrives faster than we can process it, it may be desirable to ignore older information.</li> </ul> <p>Motion allows LLM pipeline developers to define and incrementally maintain self-updating prompts in Python. With Motion, we define components that represent prompt sub-parts, and flows that represent how to assemble sub-parts into a prompt for an LLM in real-time and how to self-updatingly update sub-parts in the background based on new information.</p> <p>Motion's execution engine serves cached prompt sub-parts for minimal real-time latency and handles concurrency and sub-part consistency when running flows that update sub-parts. All prompt sub-parts are backed by a key-value store. You can run Motion components anywhere and in any number of Python processes (e.g., in a notebook, in a serverless function, in a web server) at the same time for maximal availability.</p>"},{"location":"#should-i-use-motion","title":"Should I use Motion?","text":"<p>Motion is especially useful for LLM pipelines</p> <ul> <li>Need to update prompts based on new data (e.g., maintain a dynamic summary in the prompt)</li> <li>Want a Pythonic interface to build a distributed system of LLM application components</li> </ul> <p>Motion is built for developers who know how to code in Python and want to be able to control operations in their ML applications. For low-code and domain-specific development patterns (e.g., enhancing videos), you may want to check out other tools.</p>"},{"location":"#where-did-motion-come-from","title":"Where did Motion come from?","text":"<p>Motion is developed and maintained by researchers at the UC Berkeley EPIC Lab who specialize in data management for ML pipelines.</p>"},{"location":"api/application/","title":"Application","text":""},{"location":"api/application/#motion.Application","title":"<code>Application</code>","text":""},{"location":"api/application/#motion.Application.__init__","title":"<code>__init__(*args: Any, **kwargs: Any) -&gt; None</code>","text":""},{"location":"api/component-instance/","title":"ComponentInstance","text":""},{"location":"api/component-instance/#motion.ComponentInstance","title":"<code>ComponentInstance</code>","text":""},{"location":"api/component-instance/#motion.ComponentInstance.instance_name","title":"<code>instance_name: str</code>  <code>property</code>","text":"<p>Component name with a random phrase to represent the name of this instance. In the form of componentname__randomphrase.</p>"},{"location":"api/component-instance/#motion.ComponentInstance.run","title":"<code>run(flow_key: str, props: Dict[str, Any] = {}, ignore_cache: bool = False, force_refresh: bool = False, flush_update: bool = False) -&gt; Any</code>","text":"<p>Runs the flow (serve and update ops) for the keyword argument passed in. If the key is not found to have any ops, an error is raised. Only one flow key should be passed in.</p> <p>Example Usage: <pre><code>from motion import Component\n\nC = Component(\"MyComponent\")\n\n@C.init_state\ndef setUp():\n    return {\"value\": 0}\n\n@C.serve(\"add\")\ndef add(state, value):\n    return state[\"value\"] + value\n\n@C.update(\"add\")\ndef add(state, value):\n    return {\"value\": state[\"value\"] + value}\n\nif __name__ == \"__main__\":\n    with C() as c: # Create instance of C\n        c.run(\"add\", props={\"value\": 1}, flush_update=True) # (1)!\n        c.run(\"add\", props={\"value\": 1}) # Returns 1\n        c.run(\"add\", props={\"value\": 2}) # (2)!\n\n        c.run(\"add\", props={\"value\": 3})\n\n        c.run(\"add\", props={\"value\": 3}, force_refresh=True) # (3)!\n\n# 1. Waits for the update op to finish, then updates the state\n# 2. Returns 2, result state[\"value\"] = 4\n# 3. Force refreshes the state before running the flow by waiting\n#    for all pending updates to finish processing. This\n#    reruns the serve op even though the result might be cached.\n</code></pre></p> <p>Parameters:</p> Name Type Description Default <code>flow_key</code> <code>str</code> <p>Key of the flow to run.</p> required <code>props</code> <code>Dict[str, Any]</code> <p>Keyword arguments to pass into the flow ops, in addition to the state.</p> <code>{}</code> <code>ignore_cache</code> <code>bool</code> <p>If True, ignores the cache and runs the serve op. Does not force refresh the state. Defaults to False.</p> <code>False</code> <code>force_refresh</code> <code>bool</code> <p>Whether to wait for all the pending updates to finish processing, resulting in the most up-to-date state, before running the serve op. Defaults to False, where a stale version of the state or a cached result may be used.</p> <code>False</code> <code>flush_update</code> <code>bool</code> <p>If True, waits for the update op to finish executing before returning. If the update queue hasn't reached batch_size yet, the update op runs anyways. Force refreshes the state after the update op completes. Defaults to False.</p> <code>False</code> <p>Raises:     ValueError: If more than one flow key-value pair is passed.     RuntimeError:         If flush_update is called and the component instance update         processes are disabled.</p> <p>Returns:</p> Name Type Description <code>Any</code> <code>Any</code> <p>Result of the serve call. Might take a long time</p> <code>Any</code> <p>to run if <code>flush_update = True</code> and the update operation is</p> <code>Any</code> <p>computationally expensive.</p>"},{"location":"api/component-instance/#motion.ComponentInstance.arun","title":"<code>arun(flow_key: str, props: Dict[str, Any] = {}, ignore_cache: bool = False, force_refresh: bool = False, flush_update: bool = False) -&gt; Awaitable[Any]</code>  <code>async</code>","text":"<p>Async version of run. Runs the flow (serve and update ops) for the specified key. You should use arun if either the serve or update op is an async function.</p> <p>Example Usage: <pre><code>from motion import Component\nimport asyncio\n\nC = Component(\"MyComponent\")\n\n@C.serve(\"sleep\")\nasync def sleep(state, value):\n    await asyncio.sleep(value)\n    return \"Slept!\"\n\nasync def main():\n    with C() as c:\n        await c.arun(\"sleep\", props={\"value\": 1})\n\nif __name__ == \"__main__\":\n    asyncio.run(main())\n</code></pre></p> <p>Parameters:</p> Name Type Description Default <code>flow_key</code> <code>str</code> <p>Key of the flow to run.</p> required <code>props</code> <code>Dict[str, Any]</code> <p>Keyword arguments to pass into the flow ops, in addition to the state.</p> <code>{}</code> <code>ignore_cache</code> <code>bool</code> <p>If True, ignores the cache and runs the serve op. Does not force refresh the state. Defaults to False.</p> <code>False</code> <code>force_refresh</code> <code>bool</code> <p>Whether to wait for all the pending updates to finish processing, resulting in the most up-to-date state, before running the serve op. Defaults to False, where a stale version of the state or a cached result may be used.</p> <code>False</code> <code>flush_update</code> <code>bool</code> <p>If True, waits for the update op to finish executing before returning. If the update queue hasn't reached batch_size yet, the update op runs anyways. Force refreshes the state after the update op completes. Defaults to False.</p> <code>False</code> <p>Raises:</p> Type Description <code>ValueError</code> <p>If more than one flow key-value pair is passed. If flush_update is called and the component instance update processes are disabled.</p> <p>Returns:</p> Type Description <code>Awaitable[Any]</code> <p>Awaitable[Any]: Awaitable Result of the serve call.</p>"},{"location":"api/component-instance/#motion.ComponentInstance.gen","title":"<code>gen(flow_key: str, props: Dict[str, Any] = {}, ignore_cache: bool = False, force_refresh: bool = False, flush_update: bool = False) -&gt; Generator[Any, None, None]</code>","text":"<p>Runs the flow (serve and update ops) for the specified key and yields the results as they come in, as a generator. Use this if your serve op is a generator function. If your serve op just returns a value, use run instead. You should use agen as opposed to gen if your serve op is an async generator function.</p> <p>Example Usage: <pre><code>from motion import Component\nimport asyncio\n\nC = Component(\"MyComponent\")\n\n@C.serve(\"count\")\ndef count(state, value):\n    for i in range(value):\n        yield i\n\ndef main():\n    with C() as c:\n        for elem in c.gen(\"count\", props={\"value\": 3}): # (1)!\n            print(elem) # Prints 0, 1, 2\n\nif __name__ == \"__main__\":\n    asyncio.run(main())\n\n# 1. Iterates over the generator returned by the \"count\" serve op\n</code></pre></p> <p>Parameters:</p> Name Type Description Default <code>flow_key</code> <code>str</code> <p>Key of the flow to run.</p> required <code>props</code> <code>Dict[str, Any]</code> <p>Keyword arguments to pass into the flow ops, in addition to the state.</p> <code>{}</code> <code>ignore_cache</code> <code>bool</code> <p>If True, ignores the cache and runs the serve op. Does not force refresh the state. Defaults to False.</p> <code>False</code> <code>force_refresh</code> <code>bool</code> <p>Whether to wait for all the pending updates to finish processing, resulting in the most up-to-date state, before running the serve op. Defaults to False, where a stale version of the state or a cached result may be used.</p> <code>False</code> <code>flush_update</code> <code>bool</code> <p>If True, waits for the update op to finish executing before returning. If the update queue hasn't reached batch_size yet, the update op runs anyways. Force refreshes the state after the update op completes. Defaults to False.</p> <code>False</code> <p>Raises:</p> Type Description <code>ValueError</code> <p>If more than one flow key-value pair is passed. If flush_update is called and the component instance update processes are disabled.</p> <p>Returns:</p> Type Description <code>Generator[Any, None, None]</code> <p>Awaitable[Any]: Awaitable Result of the serve call.</p>"},{"location":"api/component-instance/#motion.ComponentInstance.agen","title":"<code>agen(flow_key: str, props: Dict[str, Any] = {}, ignore_cache: bool = False, force_refresh: bool = False, flush_update: bool = False) -&gt; AsyncGenerator[Any, None]</code>  <code>async</code>","text":"<p>Async version of gen. Runs the flow (serve and update ops) for the specified key and yields the results as they come in, as a generator. Use this if your serve op is an async generator function. You should use agen as opposed to gen if your serve op is an async function.</p> <p>Example Usage: <pre><code>from motion import Component\nimport asyncio\n\nC = Component(\"MyComponent\")\n\n@C.serve(\"count\")\nasync def count(state, value):\n    for i in range(value):\n        yield i\n        await asyncio.sleep(i)\n\nasync def main():\n    with C() as c:\n        async for elem in c.agen(\"count\", props={\"value\": 3}):\n            print(elem) # Prints 0, 1, 2\n\nif __name__ == \"__main__\":\n    asyncio.run(main())\n</code></pre></p> <p>Parameters:</p> Name Type Description Default <code>flow_key</code> <code>str</code> <p>Key of the flow to run.</p> required <code>props</code> <code>Dict[str, Any]</code> <p>Keyword arguments to pass into the flow ops, in addition to the state.</p> <code>{}</code> <code>ignore_cache</code> <code>bool</code> <p>If True, ignores the cache and runs the serve op. Does not force refresh the state. Defaults to False.</p> <code>False</code> <code>force_refresh</code> <code>bool</code> <p>Whether to wait for all the pending updates to finish processing, resulting in the most up-to-date state, before running the serve op. Defaults to False, where a stale version of the state or a cached result may be used.</p> <code>False</code> <code>flush_update</code> <code>bool</code> <p>If True, waits for the update op to finish executing before returning. If the update queue hasn't reached batch_size yet, the update op runs anyways. Force refreshes the state after the update op completes. Defaults to False.</p> <code>False</code> <p>Raises:</p> Type Description <code>ValueError</code> <p>If more than one flow key-value pair is passed. If flush_update is called and the component instance update processes are disabled.</p> <p>Returns:</p> Type Description <code>AsyncGenerator[Any, None]</code> <p>Awaitable[Any]: Awaitable Result of the serve call.</p>"},{"location":"api/component-instance/#motion.ComponentInstance.read_state","title":"<code>read_state(key: str, default_value: Optional[Any] = None) -&gt; Any</code>","text":"<p>Gets the current value for the key in the component instance's state.</p> <p>Usage: <pre><code>from motion import Component\n\nC = Component(\"MyComponent\")\n\n@C.init_state\ndef setUp():\n    return {\"value\": 0}\n\n# Define serve and update operations\n...\n\nif __name__ == \"__main__\":\n    with C() as c_instance:\n        c_instance.read_state(\"value\") # Returns 0\n        c_instance.run(...)\n        c_instance.read_state(\"value\") # This will return the current\n        # value of \"value\" in the state\n</code></pre></p> <p>Parameters:</p> Name Type Description Default <code>key</code> <code>str</code> <p>Key in the state to get the value for.</p> required <code>default_value</code> <code>Optional[Any]</code> <p>Default value to return if the key is not found. Defaults to None.</p> <code>None</code> <p>Returns:</p> Name Type Description <code>Any</code> <code>Any</code> <p>Current value for the key, or default_value if the key</p> <code>Any</code> <p>is not found.</p>"},{"location":"api/component-instance/#motion.ComponentInstance.write_state","title":"<code>write_state(state_update: Dict[str, Any]) -&gt; None</code>","text":"<p>Writes the state update to the component instance's state. If a update op is currently running, the state update will be applied after the update op is finished. Warning: this could take a while if your update ops take a long time!</p> <p>Usage: <pre><code>from motion import Component\n\nC = Component(\"MyComponent\")\n\n@C.init_state\ndef setUp():\n    return {\"value\": 0}\n\n# Define serve and update operations\n...\n\nif __name__ == \"__main__\":\n    with C() as c_instance:\n        c_instance.read_state(\"value\") # Returns 0\n        c_instance.write_state({\"value\": 1, \"value2\": 2})\n        c_instance.read_state(\"value\") # Returns 1\n        c_instance.read_state(\"value2\") # Returns 2\n</code></pre></p> <p>Parameters:</p> Name Type Description Default <code>state_update</code> <code>Dict[str, Any]</code> <p>Dictionary of key-value pairs to update the state with.</p> required <code>latest</code> <code>bool</code> <p>Whether or not to apply the update to the latest version of the state. If true, Motion will redownload the latest version of the state and apply the update to that version. You only need to set this to true if you are updating an instance you connected to a while ago and might be outdated. Defaults to False.</p> required"},{"location":"api/component-instance/#motion.ComponentInstance.flush_update","title":"<code>flush_update(flow_key: str) -&gt; None</code>","text":"<p>Flushes the update queue corresponding to the flow key, if it exists, and updates the instance state. Warning: this is a blocking operation and could take a while if your update op takes a long time!</p> <p>Example Usage: <pre><code>from motion import Component\n\nC = Component(\"MyComponent\")\n\n@C.init_state\ndef setUp():\n    return {\"value\": 0}\n\n@C.serve(\"add\")\ndef add(state, value):\n    return state[\"value\"] + value\n\n@C.update(\"add\")\ndef add(state, value):\n    return {\"value\": state[\"value\"] + value}\n\n@C.serve(\"multiply\")\ndef multiply(state, value):\n    return state[\"value\"] * value\n\nif __name__ == \"__main__\":\n    with C() as c: # Create instance of C\n        c.run(\"add\", props={\"value\": 1})\n        c.flush_update(\"add\") # (1)!\n        c.run(\"add\", props={\"value\": 2}) # This will use the updated state\n\n# 1. Waits for the update op to finish, then updates the state\n</code></pre></p> <p>Parameters:</p> Name Type Description Default <code>flow_key</code> <code>str</code> <p>Key of the flow.</p> required <p>Raises:</p> Type Description <code>RuntimeError</code> <p>If the component instance was initialized as disable_update_task.</p>"},{"location":"api/component-instance/#motion.ComponentInstance.shutdown","title":"<code>shutdown(wait_for_logging_threads: bool = False) -&gt; None</code>","text":"<p>Shuts down a Motion component instance, saving state. Automatically called when the instance is garbage collected.</p> <p>Usage: <pre><code>from motion import Component\n\nC = Component(\"MyComponent\")\n\n@C.init_state\ndef setUp():\n    return {\"value\": 0}\n\n# Define serve and update operations\n\nif __name__ == \"__main__\":\n    c_instance = C()\n    c_instance.run(...)\n    c_instance.run(...)\n    c_instance.shutdown()\n\n    # Or, use a context manager\n    with C() as c_instance:\n        c_instance.run(...)\n        c_instance.run(...)\n</code></pre></p>"},{"location":"api/component-instance/#motion.ComponentInstance.close","title":"<code>close(wait_for_logging_threads: bool = False) -&gt; None</code>","text":"<p>Alias for shutdown.</p> <p>Usage: <pre><code>from motion import Component\n\nC = Component(\"MyComponent\")\n\n@C.init_state\ndef setUp():\n    return {\"value\": 0}\n\n# Define serve and update operations\n\nif __name__ == \"__main__\":\n    c_instance = C()\n    c_instance.run(...)\n    c_instance.run(...)\n    c_instance.close()\n\n    # Or, use a context manager\n    with C() as c_instance:\n        c_instance.run(...)\n        c_instance.run(...)\n</code></pre></p> <p>Parameters:</p> Name Type Description Default <code>wait_for_logging_threads</code> <code>bool</code> <p>Defaults to False.</p> <code>False</code>"},{"location":"api/component/","title":"Component","text":""},{"location":"api/component/#motion.Component","title":"<code>Component</code>","text":"<p>Component class for creating Motion components. Here are some examples:</p> BasicMultiple FlowsBatching update operations <pre><code>from motion import Component\n\nAdderComponent = Component(\"MyAdder\")\n\n@AdderComponent.init_state\ndef setUp():\n    return {\"value\": 0}\n\n@AdderComponent.serve(\"add\")\ndef plus(state, props):\n    return state[\"value\"] + props[\"value\"]\n\n@AdderComponent.update(\"add\")\ndef add(state, props):\n    return {\"value\": props.serve_result}\n\nif __name__ == \"__main__\":\n    c = AdderComponent() # Create instance of AdderComponent\n    c.run(\"add\", props={\"value\": 1}, flush_update=True) # Blocks\n    # until update is done. Resulting state is {\"value\": 1}\n    c.run(\"add\", props={\"value\": 2}) # Will return 3, not waiting\n    # for update operation.\n    # Resulting state will eventually be {\"value\": 3}\n</code></pre> <pre><code>from motion import Component\n\nCalculator = Component(\"MyCalculator\")\n\n@Calculator.init_state\ndef setUp():\n    return {\"value\": 0}\n\n@Calculator.serve(\"add\")\ndef plus(state, props):\n    return state[\"value\"] + props[\"value\"]\n\n@Calculator.serve(\"subtract\")\ndef minus(state, props):\n    return state[\"value\"] - props[\"value\"]\n\n@Calculator.update([\"add\", \"subtract\"])\ndef decrement(state, props):\n    return {\"value\": props.serve_result}\n\nif __name__ == \"__main__\":\n    c = Calculator()\n    c.run(\"add\", props={\"value\": 1}, flush_update=True) # Will return 1,\n    # blocking until update is done. Resulting state is {\"value\": 1}\n    c.run(\"subtract\", props={\"value\": 1}, flush_update=True)\n    # Will return 0, blocking until update is done. Resulting state is #\n    # {\"value\": 0}\n</code></pre> <pre><code>from motion import Component\nimport numpy as np\n\nMLMonitor = Component(\"Monitoring_ML_Component\")\n\n@MLMonitor.init_state\ndef setUp():\n    return {\n        \"model\": YOUR_MODEL_HERE,\n        \"historical_values\": [],\n        \"historical_serve_res\": []\n    }\n\n@MLMonitor.serve(\"predict\")\ndef predict(state, props):\n    return state[\"model\"].predict(props[\"features\"])\n\n@MLMonitor.update(\"features\")\ndef monitor(state, props):\n\n    values = state[\"historical_values\"] + [props[\"features\"]]\n    serve_results = state[\"historical_serve_res\"] + [props.serve_result]\n\n    # Check drift every 10 values\n    if len(values) == 10:\n        if YOUR_ANOMALY_ALGORITHM(values, serve_results):\n            # Fire an alert\n            YOUR_ALERT_FUNCTION()\n        values = []\n        serve_results = []\n\n    return {\n        \"historical_values\": values,\n        \"historical_serve_res\": serve_results\n    }\n\nif __name__ == \"__main__\":\n    c = MLMonitor() # Create instance\n    c.run(\"predict\", props={\"features\": YOUR_FEATURES_HERE})\n    # Some alert may be fired in the background!\n</code></pre>"},{"location":"api/component/#motion.Component.name","title":"<code>name: str</code>  <code>property</code>","text":"<p>Name of the component.</p> <p>Example Usage: <pre><code>from motion import Component\n\nMyComponent = Component(\"MyComponent\")\nprint(MyComponent.name) # Prints \"MyComponent\"\n</code></pre></p> <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>Component name.</p>"},{"location":"api/component/#motion.Component.params","title":"<code>params: Dict[str, Any]</code>  <code>property</code>","text":"<p>Parameters to use in component functions.</p> <p>Example Usage: <pre><code>from motion import Component\n\nMyComponent = Component(\n    \"MyComponent\",\n    params={\"param1\": 1, \"param2\": 2}\n)\n\n@MyComponent.init_state\ndef setUp():\n    return {\"value\": 0}\n\n@MyComponent.serve(\"add\")\ndef plus(state, value):\n    # Access params with MyComponent.params[\"param_name\"]\n    return state[\"value\"] + value + MyComponent.params[\"param1\"] +\n    MyComponent.params[\"param2\"]\n</code></pre></p> <p>Returns:</p> Type Description <code>Dict[str, Any]</code> <p>Dict[str, Any]: Parameters dictionary.</p>"},{"location":"api/component/#motion.Component.__init__","title":"<code>__init__(name: str, params: Dict[str, Any] = {}, cache_ttl: int = DEFAULT_KEY_TTL)</code>","text":"<p>Creates a new Motion component.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>Name of the component.</p> required <code>params</code> <code>Dict[str, Any]</code> <p>Parameters to be accessed by the component. Defaults to {}. Usage: <code>C.params[\"param_name\"]</code> if C is the Component you have created.</p> <code>{}</code> <code>cache_ttl</code> <code>int</code> <p>Time to live for cached serve results (seconds). Defaults to 1 day. Set to 0 to disable caching.</p> <code>DEFAULT_KEY_TTL</code>"},{"location":"api/component/#motion.Component.serve","title":"<code>serve(keys: Union[str, List[str]]) -&gt; Callable</code>","text":"<p>Decorator for any serve operation for a flow through the component. Takes in a string or list of strings that represents the flow key. If the decorator is called with a list of strings, each flow key will be mapped to the same serve function.</p> 2 arguments required for an serve operation <ul> <li><code>state</code>: The current state of the component instance, which is a     dictionary with string keys and any-type values.</li> <li><code>props</code>: The properties of the current flow, which is passed via     the <code>run</code> method of the component instance. You can add to     the <code>props</code> dictionary in the serve op, and the modified     <code>props</code> will be passed to the subsequent update ops in the flow.     Props are short-lived and die after the flow's update op     finishes.</li> </ul> <p>Components can have multiple serve ops, but no flow key within the component can have more than one serve op. serve ops should not modify the state object. If you want to modify the state object, write an <code>update</code> op for your flow.</p> <p>Example Usage: <pre><code>from motion import Component\n\nMyComponent = Component(\"MyComponent\")\n\n@MyComponent.init_state\ndef setUp():\n    return {\"value\": 0}\n\n@MyComponent.serve(\"add\")\ndef add(state, props):\n    return state[\"value\"] + props[\"value\"]\n\n@MyComponent.serve(\"multiply\")\ndef multiply(state, props):\n    return state[\"value\"] * props[\"value\"]\n\nc = MyComponent()\nc.run(\"add\", props={\"value\": 1}, flush_update=True) # Returns 1\nc.run(\"multiply\", props={\"value\": 2}) # Returns 2\n</code></pre></p> <p>Parameters:</p> Name Type Description Default <code>keys</code> <code>Union[str, List[str]]</code> <p>String or list of strings that represent the input keyword(s) for the serve flow.</p> required <p>Returns:</p> Name Type Description <code>Callable</code> <code>Callable</code> <p>Decorated serve function.</p>"},{"location":"api/component/#motion.Component.update","title":"<code>update(keys: Union[str, List[str]], discard_policy: DiscardPolicy = DiscardPolicy.NONE, discard_after: Optional[int] = None) -&gt; Any</code>","text":"<p>Decorator for any update operations for flows through the component. Takes in a string or list of strings that represents the flow key. If the decorator is called with a list of strings, each flow key will be mapped to the same update operation.</p> 2 arguments required for a update operation <ul> <li><code>state</code>: The current state of the component, represented as a dictionary.</li> <li><code>props</code>: The properties of the current flow, which could contain properties that were added to the <code>props</code> dictionary in the serve op before this update op. Props are short-lived and die after the flow's update op finishes.</li> </ul> <p>Components can have multiple update ops, and the same key can also have multiple update ops. Update functions should return a dictionary of state updates to be merged with the current state.</p> <p>See <code>DiscardPolicy</code> for more info on how to expire update operations if you expect there to be backpressure for an update operation.</p> <p>Example Usage: <pre><code>from motion import Component\n\nMyComponent = Component(\"MyComponent\")\n\n\n@MyComponent.init_state\ndef setUp():\n    return {\"value\": 0}\n\n\n@MyComponent.serve(\"multiply\")\ndef multiply(state, props):\n    props[\"something\"] = props[\"value\"] + 1\n    return state[\"value\"] * props[\"value\"]\n\n\n@MyComponent.update(\"multiply\")\ndef multiply(state, props):\n    return {\"value\": props[\"something\"]}\n\n\nif __name__ == \"__main__\":\n    c = MyComponent()\n    print(\n        c.run(\"multiply\", props={\"value\": 2}, flush_update=True)\n    )  # Returns 0 and state updates to {\"value\": 3}\n    print(\n        c.run(\"multiply\", props={\"value\": 3}, flush_update=True)\n    )  # Returns 9, update will execute\n    # to get state[\"value\"] = 4\n    print(\n        c.run(\"multiply\", props={\"value\": 4}, flush_update=True)\n    )  # Returns 4 * 4 = 16\n</code></pre></p> <p>Parameters:</p> Name Type Description Default <code>keys</code> <code>Union[str, List[str]]</code> <p>String or list of strings that represent the input keyword(s) for the update flow.</p> required <code>discard_policy</code> <code>DiscardPolicy</code> <p>Policy for expiring update operations. Defaults to DiscardPolicy.NONE.</p> <code>NONE</code> <code>discard_after</code> <code>Optional[int]</code> <p>Number of updates or seconds after which to expire the update operation. Defaults to None.</p> <code>None</code> <p>Returns:</p> Name Type Description <code>Callable</code> <code>Any</code> <p>Decorated update function.</p>"},{"location":"api/component/#motion.Component.init_state","title":"<code>init_state(func: Callable) -&gt; Callable</code>","text":"<p>Decorator for the init_state function. This function is called once at the beginning of the component's lifecycle. The decorated function should return a dictionary that represents the initial state of the component.</p> <p>Usage: <pre><code>from motion import Component\n\nMyComponent = Component(\"MyComponent\")\n\n@MyComponent.init_state\ndef setUp():\n    return {\"value\": 0}\n</code></pre></p> <p>Parameters:</p> Name Type Description Default <code>func</code> <code>Callable</code> <p>Function that initializes a state. Must return a dictionary.</p> required <p>Returns:</p> Name Type Description <code>Callable</code> <code>Callable</code> <p>Decorated init_state function.</p>"},{"location":"api/component/#motion.Component.__call__","title":"<code>__call__(instance_id: str = '', init_state_params: Dict[str, Any] = {}, logging_level: str = 'WARNING', update_task_type: Literal['thread', 'process'] = 'thread', disable_update_task: bool = False, redis_socket_timeout: int = 60, config_path: str = '.motionrc.yml', flush_on_exit: bool = False) -&gt; ComponentInstance</code>","text":"<p>Creates and returns a new instance of a Motion component. See <code>ComponentInstance</code> docs for more info.</p> <p>Usage: <pre><code>from motion import Component\n\nMyComponent = Component(\"MyComponent\")\n\n@MyComponent.init_state\ndef setUp(starting_val):\n    return {\"value\": starting_val}\n\n# Define serve and update operations\n@MyComponent.serve(\"key1\")\ndef ...\n\n@MyComponent.update(\"key1)\ndef ...\n\n# Creates instance of MyComponent\nif __name__ == \"__main__\":\n    c_instance = MyComponent(init_state_params={\"starting_val\": 3})\n    c_instance.run(..)\n    c_instance.shutdown()\n</code></pre></p> <p>You can also use component instances as context managers, which is the recommended way to use them (because it will automatically gracefully shut down the component instance when the context manager exits): <pre><code>...\nif __name__ == \"__main__\":\n    with MyComponent(init_state_params={\"starting_val\": 3}) as c_instance:\n        c_instance.run(..)\n</code></pre></p> <p>Parameters:</p> Name Type Description Default <code>instance_id</code> <code>str</code> <p>id of the component instance. Defaults to \"\" which will generate a random id.</p> <code>''</code> <code>init_state_params</code> <code>Dict[str, Any]</code> <p>Parameters to pass into the init_state function. Defaults to {}.</p> <code>{}</code> <code>logging_level</code> <code>str</code> <p>Logging level for the Motion logger. Uses the logging library. Defaults to \"WARNING\".</p> <code>'WARNING'</code> <code>update_task_type</code> <code>str</code> <p>Type of update task to use. Can be \"thread\" or \"process\". \"thread\" has lower overhead but is not recommended for CPU-intensive update operations. \"process\" is recommended for CPU-intensive operations (e.g., fine-tuning a model) but has higher startup overhead. Defaults to \"thread\".</p> <code>'thread'</code> <code>disable_update_task</code> <code>bool</code> <p>Whether or not to disable the component instance update ops. Useful for printing out state values without running flows. Defaults to False.</p> <code>False</code> <code>redis_socket_timeout</code> <code>int</code> <p>Timeout for redis socket connections (seconds). Defaults to 60. This means the redis connection will close if idle for 60 seconds.</p> <code>60</code> <code>config_path</code> <code>str</code> <p>Path to config file of env vars. Defaults to \".motionrc.yml\".</p> <code>'.motionrc.yml'</code> <code>flush_on_exit</code> <code>bool</code> <p>Whether or not to flush the update queue on exit/shutdown. This is useful when running flows in serverless environments, where you want to make sure all updates are finished after the result is returned, before the function exits. Defaults to False.</p> <code>False</code> <p>Returns:     ComponentInstance: Component instance to run flows with.</p>"},{"location":"api/component/#motion.Component.save_state","title":"<code>save_state(func: Callable) -&gt; Callable</code>","text":"<p>Decorator for the save_state function. This function saves the state of the component to be accessible in future component instances of the same name.</p> <p>Usage: <pre><code>from motion import Component\n\nMyComponent = Component(\"MyComponent\")\n\n@c.save_state\ndef save(state):\n    # state might have other unpicklable keys, like a DB connection\n    return {\"fit_count\": state[\"fit_count\"]}\n</code></pre></p> <p>Parameters:</p> Name Type Description Default <code>func</code> <code>Callable</code> <p>Function that returns a cloudpickleable object.</p> required <p>Returns:</p> Name Type Description <code>Callable</code> <code>Callable</code> <p>Decorated save_state function.</p>"},{"location":"api/component/#motion.Component.load_state","title":"<code>load_state(func: Callable) -&gt; Callable</code>","text":"<p>Decorator for the load_state function. This function loads the state of the component from the unpickled state.</p> <p>Usage: <pre><code>from motion import Component\n\nMyComponent = Component(\"MyComponent\")\n\n@c.load_state\ndef load(state):\n    conn = sqlite3.connect(\":memory:\")\n    cursor = conn.cursor()\n    return {\"cursor\": cursor, \"fit_count\": state[\"fit_count\"]}\n</code></pre></p> <p>Parameters:</p> Name Type Description Default <code>func</code> <code>Callable</code> <p>Function that consumes a cloudpickleable object. Should return a dictionary representing the state of the component instance.</p> required <p>Returns:</p> Name Type Description <code>Callable</code> <code>Callable</code> <p>Decorated load_state function.</p>"},{"location":"api/component/#motion.DiscardPolicy","title":"<code>DiscardPolicy</code>","text":"<p>             Bases: <code>Enum</code></p> <p>Defines the policy for discarding items in an update operation's queue. Each component instance has a queue for each update operation. Items in the queue are processed in first-in-first-out (FIFO) order, and items in the queue can delete based on the discard policy set by the developer.</p> <p>Attributes:</p> Name Type Description <code>NONE</code> <p>Indicates no discard policy. Items in the queue do not delete.</p> <code>NUM_NEW_UPDATES</code> <p>Items delete based on the number of new updates. Once the number of new updates exceeds a certain threshold, the oldest items are removed.</p> <code>SECONDS</code> <p>Items delete based on time. Items older than a specified number of seconds at the time of processing are removed.</p> <p>Use the <code>discard_after</code> and <code>discard_policy</code> arguments in <code>Component.update</code> decorator to set the discard policy for an update operation.</p> <p>Example Usage: <pre><code>from motion import Component, DiscardPolicy\n\nC = Component(\"C\")\n\n@C.init_state\ndef setup():\n    return {\"default_value\": 0, \"some_value\": 0, \"another_value\": 0}\n\n@C.update(\n    \"something\",\n    discard_after=10,\n    discard_policy=DiscardPolicy.NUM_NEW_UPDATES\n)\ndef update_num_new(state, props):\n    # Do an expensive operation that could take a while\n    ...\n    return {\"some_value\": state[\"some_value\"] + props[\"value\"]}\n\n@C.update(\"something\", discard_after=1, discard_policy=DiscardPolicy.SECONDS)\ndef update_seconds(state, props):\n    # Do an expensive operation that could take a while\n    ...\n    return {\"another_value\": state[\"another_value\"] + props[\"value\"]}\n\n@C.update(\"something\")\ndef update_default(state, props):\n    # Do an expensive operation that could take a while\n    ...\n    return {\"default_value\": state[\"default_value\"] + props[\"value\"]}\n\nif __name__ == \"__main__\":\n    c = C()\n\n    # If we do many runs of \"something\", the update queue will grow\n    # and the policy will be automatically enforced by Motion.\n\n    for i in range(100):\n        c.run(\"something\", props={\"value\": str(i)})\n\n    # Flush the update queue (i.e., wait for all updates to finish)\n    c.flush_update(\"something\")\n\n    print(c.read_state(\"default_value\")) # (1)!\n\n    print(c.read_state(\"some_value\")) # (2)!\n\n    print(c.read_state(\"another_value\")) # (3)!\n\n    c.shutdown()\n</code></pre></p> <ol> <li> <p>The default policy is to not delete any items (DiscardPolicy.NONE), so the value of <code>default_value</code> will be the sum of all the values passed to <code>run</code> (i.e., <code>sum(range(100))</code>).</p> </li> <li> <p>The NUM_NEW_UPDATES policy will delete items in the queue once the number of new updates exceeds a certain threshold. The threshold is set by the <code>discard_after</code> argument in the <code>update</code> decorator. So the result will be &lt; 4950 because the NUM_NEW_UPDATES policy will have deleted some items.</p> </li> <li> <p>This will be &lt; 4950 because the SECONDS policy will have deleted some items (only whatever updates could have been processed in the second after they were added to the queue).</p> </li> </ol>"},{"location":"api/component/#motion.DiscardPolicy.NONE","title":"<code>NONE = 0</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>No discard policy. Does not discard items in the queue.</p>"},{"location":"api/component/#motion.DiscardPolicy.NUM_NEW_UPDATES","title":"<code>NUM_NEW_UPDATES = 1</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Delete items based on the number of new updates enqueued.</p>"},{"location":"api/component/#motion.DiscardPolicy.SECONDS","title":"<code>SECONDS = 2</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Delete items based on time (in seconds).</p>"},{"location":"api/mtable/","title":"MTable","text":""},{"location":"api/mtable/#motion.MTable","title":"<code>MTable</code>","text":"Source code in <code>motion/__init__.py</code> <pre><code>class MTable:  # type: ignore\n    def __init__(self, *args: Any, **kwargs: Any) -&gt; None:\n        raise TableImportError()\n</code></pre>"},{"location":"api/props-and-state/","title":"Props and State","text":""},{"location":"api/props-and-state/#motion.dicts.Properties","title":"<code>Properties</code>","text":"<p>             Bases: <code>dict</code></p> <p>Dictionary that stores properties of a flow.</p> <p>Example usage:</p> <pre><code>from motion import Component\n\nsome_component = Component(\"SomeComponent\")\n\n@some_component.init_state\ndef setUp():\n    return {\"model\": ...}\n\n@some_component.serve(\"image\")\ndef predict_image(state, props):\n    # props[\"image_embedding\"] is passed in at runtime\n    return state[\"model\"](props[\"image_embedding\"])\n\n@some_component.update(\"image\")\ndef monitor_prediction(state, props):\n    # props.serve_result is the result of the serve operation\n    if props.serve_result &gt; some_threshold:\n        trigger_alert()\n\nif __name__ == \"__main__\":\n    c = some_component()\n    c.run(\"image\", props={\"image_embedding\": ...})\n</code></pre>"},{"location":"api/props-and-state/#motion.dicts.Properties.serve_result","title":"<code>serve_result: Any</code>  <code>property</code>","text":"<p>Stores the result of the serve operation. Can be accessed in the update operation, not the serve operation.</p> <p>Returns:</p> Name Type Description <code>Any</code> <code>Any</code> <p>Result of the serve operation.</p>"},{"location":"api/props-and-state/#motion.dicts.State","title":"<code>State</code>","text":"<p>             Bases: <code>dict</code></p> <p>Dictionary that stores state for a component instance. The instance id is stored in the <code>instance_id</code> attribute.</p> <p>Example usage:</p> <pre><code>from motion import Component\n\nsome_component = Component(\"SomeComponent\")\n\n@some_component.init_state\ndef setUp():\n    return {\"model\": ...}\n\n@some_component.serve(\"retrieve\")\ndef retrieve_nn(state, props):\n    # model can be accessed via state[\"model\"]\n    prediction = state[\"model\"](props[\"image_embedding\"])\n    # match the prediction to some other data to do a retrieval\n    nn_component_instance = SomeOtherMotionComponent(state.instance_id)\n    return nn_component_instance.run(\"retrieve\", props={\"prediction\": prediction})\n\nif __name__ == \"__main__\":\n    c = some_component()\n    nearest_neighbors = c.run(\"retrieve\", props={\"image_embedding\": ...})\n</code></pre>"},{"location":"api/props-and-state/#motion.dicts.State.instance_id","title":"<code>instance_id: str</code>  <code>property</code>","text":"<p>Returns the instance id of the component. Useful if wanting to create other component instances within a serve or update operation.</p>"},{"location":"api/props-and-state/#motion.df.MDataFrame","title":"<code>MDataFrame</code>","text":"<p>             Bases: <code>DataFrame</code></p> <p>Wrapper around pandas DataFrame that allows for pyarrow-based serialization. This is to be used in a motion component's state.</p> <p>Simply use this class instead of pandas DataFrame. For example: <pre><code>from motion import MDataFrame, Component\n\nC = Component(\"MyDFComponent\")\n\n@C.init_state\ndef setUp():\n    df = MDataFrame({\"value\": [0, 1, 2]})\n    return {\"df\": df}\n</code></pre></p> Source code in <code>motion/df.py</code> <pre><code>class MDataFrame(pd.DataFrame):\n    \"\"\"Wrapper around pandas DataFrame that allows for pyarrow-based\n    serialization. This is to be used in a motion component's state.\n\n    Simply use this class instead of pandas DataFrame. For example:\n    ```python\n    from motion import MDataFrame, Component\n\n    C = Component(\"MyDFComponent\")\n\n    @C.init_state\n    def setUp():\n        df = MDataFrame({\"value\": [0, 1, 2]})\n        return {\"df\": df}\n    ```\n    \"\"\"\n\n    def __getstate__(self) -&gt; dict:\n        # Serialize with pyarrow\n        table = pa.Table.from_pandas(self)\n        # Convert the PyArrow Table to a PyArrow Buffer\n        sink = pa.BufferOutputStream()\n        writer = pa.ipc.new_stream(sink, table.schema)\n        writer.write_table(table)\n        writer.close()\n\n        buffer = sink.getvalue()\n        return {\"table\": buffer}\n\n    def __setstate__(self, state: dict) -&gt; None:\n        # Convert the PyArrow Buffer to a PyArrow Table\n        buf = state[\"table\"]\n        reader = pa.ipc.open_stream(buf)\n        df = reader.read_pandas()\n        self.__init__(df)  # type: ignore\n</code></pre>"},{"location":"api/props-and-state/#motion.df.MDataFrame.__getstate__","title":"<code>__getstate__() -&gt; dict</code>","text":"Source code in <code>motion/df.py</code> <pre><code>def __getstate__(self) -&gt; dict:\n    # Serialize with pyarrow\n    table = pa.Table.from_pandas(self)\n    # Convert the PyArrow Table to a PyArrow Buffer\n    sink = pa.BufferOutputStream()\n    writer = pa.ipc.new_stream(sink, table.schema)\n    writer.write_table(table)\n    writer.close()\n\n    buffer = sink.getvalue()\n    return {\"table\": buffer}\n</code></pre>"},{"location":"api/props-and-state/#motion.df.MDataFrame.__setstate__","title":"<code>__setstate__(state: dict) -&gt; None</code>","text":"Source code in <code>motion/df.py</code> <pre><code>def __setstate__(self, state: dict) -&gt; None:\n    # Convert the PyArrow Buffer to a PyArrow Table\n    buf = state[\"table\"]\n    reader = pa.ipc.open_stream(buf)\n    df = reader.read_pandas()\n    self.__init__(df)  # type: ignore\n</code></pre>"},{"location":"api/state-migrator/","title":"StateMigrator","text":""},{"location":"api/state-migrator/#motion.migrate.StateMigrator","title":"<code>StateMigrator</code>","text":""},{"location":"api/state-migrator/#motion.migrate.StateMigrator.__init__","title":"<code>__init__(component: Component, migrate_func: Callable) -&gt; None</code>","text":"<p>Creates a StateMigrator object.</p> <p>Parameters:</p> Name Type Description Default <code>component</code> <code>Component</code> <p>Component to perform the migration for.</p> required <code>migrate_func</code> <code>Callable</code> <p>Function to apply to the state of each instance of the component.</p> required <p>Raises:</p> Type Description <code>TypeError</code> <p>if component is not a valid Component</p> <code>ValueError</code> <p>if migrate_func does not have exactly one parameter</p>"},{"location":"api/state-migrator/#motion.migrate.StateMigrator.migrate","title":"<code>migrate(instance_ids: List[str] = [], num_workers: int = 4) -&gt; List[MigrationResult]</code>","text":"<p>Performs the migrate_func for component instances' states. If instance_ids is empty, then migrate_func is performed for all instances of the component.</p> <p>Parameters:</p> Name Type Description Default <code>instance_ids</code> <code>List[str]</code> <p>List of instance ids to perform migration for. Defaults to empty list.</p> <code>[]</code> <code>num_workers</code> <code>int</code> <p>Number of workers to use for parallel processing the migration. Defaults to 4.</p> <code>4</code> <p>Returns:</p> Type Description <code>List[MigrationResult]</code> <p>List[MigrationResult]: List of objects with instance_id and exception keys, where exception is None if the migration was successful for that instance name.</p>"},{"location":"api/state-migrator/#motion.copy_db","title":"<code>copy_db(src: RedisParams, dest: RedisParams) -&gt; None</code>  <code>async</code>","text":"<p>Copy a component and its state from one Redis instance to another.</p> <p>Parameters:</p> Name Type Description Default <code>src</code> <code>RedisParams</code> <p>RedisParams for the source Redis instance.</p> required <code>dest</code> <code>RedisParams</code> <p>RedisParams for the destination Redis instance.</p> required"},{"location":"examples/application/","title":"Building a Motion Application","text":"<p>In this tutorial, we'll go through setting up an application of Motion components. We'll go through setting up a simple server with custom components and then demonstrate how to interact with it using Axios in a TypeScript environment.</p>"},{"location":"examples/application/#prerequisites","title":"Prerequisites","text":"<ul> <li>Motion</li> <li>FastAPI -- installed automatically with Motion</li> <li>uvicorn -- To serve the application</li> </ul>"},{"location":"examples/application/#step-1-define-some-components","title":"Step 1: Define Some Components","text":"<p>We'll write two components: one representing a counter, and another representing a calculator. The counter will increment a count every time an operation is called. The calculator will add and subtract two numbers.</p> sample_components.py<pre><code>from motion import Component\n\nCounter = Component(\"Counter\")\n\n@Counter.init_state\ndef setup():\n    return {\"count\": 0}\n\n@Counter.serve(\"increment\")\ndef increment(state, props):\n    return state[\"count\"] + 1\n\n@Counter.update(\"increment\")\ndef update_count(state, props):\n    return {\"count\": state[\"count\"] + 1}\n\nCalculator = Component(\"Calculator\")\n\n@Calculator.serve(\"add\")\ndef add(state, props):\n    return props[\"a\"] + props[\"b\"]\n\n@Calculator.serve(\"subtract\")\ndef subtract(state, props):\n    return props[\"a\"] - props[\"b\"]\n</code></pre>"},{"location":"examples/application/#step-2-create-an-application","title":"Step 2: Create an Application","text":"<p>We'll create an application that serves the two components we just defined.</p> app.py<pre><code># app.py\nfrom motion import Application\nfrom sample_components import Counter, Calculator\nimport uvicorn\n\n# Create the Motion application with both components\nmotion_app = Application(components=[Counter, Calculator])\nfastapi_app = motion_app.get_app()\n\n# Run the application using Uvicorn\nif __name__ == \"__main__\":\n    # Print secret key\n    print(motion_app.get_credentials())\n\n    uvicorn.run(fastapi_app, host=\"0.0.0.0\", port=8000)\n</code></pre> <p>In the script, we include a statement to print the secret key (which is useful if you don't specify your secret key and Motion automatically creates one for your application). Keep this key safe, as it is used to authenticate requests to the application.</p> <p>To run the application, we can run <code>python app.py</code> in the terminal. We can also run <code>uvicorn app:fastapi_app --reload</code> to run the application with hot reloading.</p> <p>One of the powerful features of FastAPI is its automatic generation of interactive API documentation. Once your server is running, you can access the API documentation by visiting <code>http://localhost:8000/docs</code> in your web browser. This documentation provides a detailed overview of all the available routes (i.e., the Counter and Calculator component flows) and allows you to directly test the API endpoints from the browser.</p>"},{"location":"examples/application/#step-3-interact-with-the-application","title":"Step 3: Interact with the Application","text":"<p>Suppose we are in TypeScript and want to interact with the application. We can use Axios to make requests to the application. First, install Axios in your web application:</p> <pre><code>npm install axios\n</code></pre> <p>Then, we can write a simple Typescript function to make requests to the application:</p> queryMotionApp.ts<pre><code>import axios from \"axios\";\n\nconst queryServer = async () =&gt; {\n  const secretToken = \"your_secret_key\"; // Replace with the secret key from your Motion application\n\n  try {\n    // Increment the Counter\n    const incrementResponse = await axios.post(\n      \"http://localhost:8000/Counter\",\n      {\n        instance_id: \"ts_testid\",\n        flow_key: \"increment\",\n        props: {},\n      },\n      {\n        headers: { Authorization: `Bearer ${secretToken}` },\n      }\n    );\n    console.log(\"Counter Increment Result:\", incrementResponse.data);\n\n    // Perform an addition using the Calculator\n    const addResponse = await axios.post(\n      \"http://localhost:8000/Calculator\",\n      {\n        instance_id: \"ts_testid\",\n        flow_key: \"add\",\n        props: { a: 20, b: 10 },\n      },\n      {\n        headers: { Authorization: `Bearer ${secretToken}` },\n      }\n    );\n    console.log(\"Addition Result:\", addResponse.data);\n  } catch (error) {\n    console.error(\"Error querying server:\", error);\n  }\n};\n\nqueryServer();\n</code></pre> <p>Since the application is served as a REST API, we can also use any other HTTP client to interact with the application.</p>"},{"location":"examples/design-patterns/","title":"Common Design Patterns","text":"<ul> <li>Component instance-per-user (prompt personalization)</li> <li>Reusing component instances (dynamic retrieval)</li> <li>Caching results to save cost (wrapper around OpenAI LLM)</li> <li>Disabled component instances</li> <li>Context manager component instances</li> <li>Generator UDFs (e.g., for streaming LLM output)</li> </ul>"},{"location":"examples/nl-query/","title":"Querying Data with Natural Language","text":"<p>In this guide, we'll create a Motion application that runs natural language queries on a group of datasets, learning from feedback and new data over time.</p>"},{"location":"examples/nl-query/#install-motion","title":"Install Motion","text":"<p>Install Motion via pip:</p> <pre><code>pip install motion-python\n</code></pre>"},{"location":"examples/nl-query/#write-components","title":"Write Components","text":"<p>Our application will consist of two components:</p> <ol> <li>A component that keeps track of the datasets we have available and their metadata.</li> <li>A component that uses an LLM to execute our natural language queries, learning prompts based on our feedback.</li> </ol> <p>TODO</p>"},{"location":"getting-started/concepts/","title":"Motion Concepts","text":"<p>Motion applications consist of components that hold state and operations that read and update state. Components and operations are connected by flows. Think of a component as representing the prompt and LLM pipeline(s) for a particular task, the state as the prompt sub-parts, and flows as the different ways to interact with the state (e.g., assemble the sub-parts into a prompt, update the sub-parts, etc).</p>"},{"location":"getting-started/concepts/#the-component-lifecycle","title":"The Component Lifecycle","text":"<p>When a component instance is first created, an <code>init</code> function initializes the component's state. The state is a dictionary of key-value pairs, representing the initial sub-parts you might want to include in your prompt. The state is persisted in a key-value store (Redis) and is loaded when the component instance is initialized again.</p> <p>Components can have multiple flows that read and update the state (i.e., prompt sub-parts). A flow is represented by a string key and consists of two user-defined operations, which run back-to-back:</p> <ul> <li> <p>serve: a function that takes in (1) a state dictionary that may not reflect all new information yet, and (2) a user-defined <code>props</code> dictionary (passed in at runtime), then returns a result back to the user.</p> </li> <li> <p>update: a function that runs in the background and takes in (1) the current state dictionary, and (2) the user-defined <code>props</code> dictionary, including the result of the serve op (accessed via <code>props.serve_result</code>). The <code>update</code> operation returns any updates to the state, which can be used in future operations. The <code>props</code> dictionary dies after the update operation for a flow. We run update operations in the background because they may be expensive and we don't want to block the serves.</p> </li> </ul> <p>Serve operations do not modify the state, while update operations do.</p>"},{"location":"getting-started/concepts/#concurrency-and-consistency-in-motions-execution-engine","title":"Concurrency and Consistency in Motion's Execution Engine","text":"<p>Since serve operations do not modify the state, you can run multiple serve operations for the same component instance in parallel (e.g., in different Python processes). However, since update operations modify the state, Motion ensures that only one update operation is running at a time for a given component instance. This is done by maintaining queues of pending update operations and issuing exclusive write locks to update operations. Each component instance has its own lock and has a queue for each of its update operations. While update operations are running, serve operations can still run with low latency using stale state. The update queue is processed in a FIFO manner.</p>"},{"location":"getting-started/concepts/#backpressure-in-processing-update-operations","title":"Backpressure in Processing Update Operations","text":"<p>Motion's execution engine experiences backpressure if a queue of pending update operations grows faster than the rate at which its update operations are completed. For example, if an update operation calls an LLM for a long prompt and takes 10 seconds to complete, and new update operations are being added to the queue every second, the queue will grow by 10 operations every second. While this does not pose problems for serve operations because serve operations can read stale state, it can cause the component instance to fall behind in processing update operations.</p> <p>Our solution to limit queue growth is to offer a configurable <code>DiscardPolicy</code> parameter for each update operation. There are two options for <code>DiscardPolicy</code>:</p> <ul> <li><code>DiscardPolicy.SECONDS</code>: If more than <code>discard_after</code> seconds have passed since the update operation u was added to the queue, u is removed from the queue and the state is not updated with u's results.</li> <li><code>DiscardPolicy.NUM_NEW_UPDATES</code>: If more than <code>discard_after</code> new update operations have been added to the queue since an update operation u was added, u is removed from the queue and the state is not updated with u's results.</li> </ul> <p>See the API docs for how to use <code>DiscardPolicy</code>.</p>"},{"location":"getting-started/concepts/#state-vs-props","title":"State vs Props","text":"<p>The difference between state and props can be a little confusing, since both are dictionaries. The main difference is that state is persistent, while props are ephemeral/limited to a flow.</p> <p>State is initialized when the component is created and persists between successive flows. Since Motion is backed by Redis, state also persists when the component is restarted. State is available to all operations for all flows, but can only be changed by update operations.</p> <p>On the other hand, props are passed in at runtime and are only available to the serve and update operations for a single flow. Props can be modified in serve operation, so they can be used to pass data between serve and update operations. Of note is <code>props.serve_result</code>, which is the result of the serve operation for a flow (and thus only accessible in update operations). This is useful for update operations that need to use the result of the serve operation. Think of props like a kwargs dictionary that becomes irrelevant after the particular flow is finished.</p>"},{"location":"getting-started/concepts/#things-to-keep-in-mind","title":"Things to Keep in Mind","text":"<ul> <li>Components can have many flows, each with their own key, serve operation, and update operation(s).</li> <li>Components can only have one serve operation per key.</li> <li>The <code>serve</code> operation is run on the main thread, while the <code>update</code> operation is run in the background. You directly get access to <code>serve</code> results, but <code>update</code> results are not accessible unless you read values from the state dictionary.</li> <li><code>serve</code> results are cached, with a default discard time of 24 hours. If you run a component twice on the same flow key-value pair, the second run will return the result of the first run. To override the caching behavior, see the API docs.</li> <li><code>update</code> operations are processed sequentially in first-in-first-out (FIFO) order. This allows state to be updated incrementally. To handle backpressure, update operations can be configured to expire after a certain amount of time or after a certain number of new update operations have been added to the queue. See the API docs for how to use <code>DiscardPolicy</code>.</li> </ul>"},{"location":"getting-started/concepts/#example-component","title":"Example Component","text":"<p>Here is an example component that computes the z-score of a value with respect to its history.</p> main.py<pre><code>from motion import Component\n\nZScoreComponent = Component(\"ZScore\")\n\n\n@ZScoreComponent.init_state\ndef setUp():\n    return {\"mean\": None, \"std\": None, \"values\": []}\n\n\n@ZScoreComponent.serve(\"number\")\ndef serve(state, props):  # (1)!\n    if state[\"mean\"] is None:\n        return None\n    return abs(props[\"value\"] - state[\"mean\"]) / state[\"std\"]\n\n\n@ZScoreComponent.update(\"number\")\ndef update(state, props):  # (2)!\n    # Result of the serve op can be accessed via\n    # props.serve_result\n    # We don't do anything with the results, but we could!\n    value_list = state[\"values\"]\n    value_list.append(props[\"value\"])\n\n    mean = sum(value_list) / len(value_list)\n    std = sum((n - mean) ** 2 for n in value_list) / len(value_list)\n    return {\"mean\": mean, \"std\": std, \"values\": value_list}\n</code></pre> <ol> <li>This function is executed on the main thread, and the result is immediately returned to the user.</li> <li>This function is executed in the background and merges the updates back to the state when ready.</li> </ol> <p>To run the component, we can create an instance of our component, <code>c</code>, and call <code>c.run</code> on the flow's key and value:</p> main.py<pre><code>if __name__ == \"__main__\":\n    import time\n    c = ZScoreComponent() # Create instance of component\n\n    # Observe 10 values of the flow's key\n    for i in range(9):\n        print(c.run(\"number\", props={\"value\": i}))  # (1)!\n\n    c.run(\"number\", props={\"value\": 9}, flush_update=True)  # (2)!\n    for i in range(10, 19):\n        print(c.run(\"number\", props={\"value\": i}))  # (3)!\n\n    print(c.run(\"number\", props={\"value\": 10})) # (4)!\n    time.sleep(5)  # Give time for the second update to finish\n    print(c.run(\"number\", props={\"value\": 10}, force_refresh=True))\n</code></pre> <ol> <li>The first few runs might return None, as the mean and std are not yet initialized.</li> <li>This will block until the resulting update operation has finished running. update ops run in the order that flows were executed (i.e., the update op for number 8 will run before the update op for number 9).</li> <li>This uses the updated state dictionary from the previous run operation, since <code>flush_update</code> also updates the state.</li> <li>This uses the cached result for 10. To ignore the cached result and rerun the serve op with a (potentially old) state, we should call <code>c.run(\"number\", props={\"value\": 10}, ignore_cache=True)</code>. To make sure we have the latest state, we can call <code>c.run(\"number\", props={\"value\": 10}, force_refresh=True)</code>.</li> </ol> <p>The output of the above code is:</p> <pre><code>&gt; python main.py\nNone\nNone\nNone\nNone\nNone\nNone\nNone\nNone\nNone\n0.6666666666666666\n0.7878787878787878\n0.9090909090909091\n1.0303030303030303\n1.1515151515151516\n1.2727272727272727\n1.393939393939394\n1.5151515151515151\n1.6363636363636365\n0.6666666666666666\n0.03327787021630613\n</code></pre> <p>Note that the <code>update</code> operation is running in a separate process, whenever new results come in. This is why the first several calls to <code>c.run</code> return <code>None</code>.</p>"},{"location":"getting-started/concepts/#component-parameters","title":"Component Parameters","text":"<p>You can inject static component parameters into your flow operations by passing them to the component constructor:</p> <pre><code>from motion import Component\n\nZScoreComponent = Component(\"ZScore\", params={\"alert_threshold\": 2.0})\n</code></pre> <p>Then, you can access the parameters in your operations:</p> <pre><code>@ZScoreComponent.serve(\"number\")\ndef serve(state, props):\n    if state[\"mean\"] is None:\n        return None\n    z_score = abs(props[\"value\"] - state[\"mean\"]) / state[\"std\"]\n    if z_score &gt; ZScoreComponent.params[\"alert_threshold\"]:\n        print(\"Alert!\")\n    return z_score\n</code></pre> <p>The <code>params</code> dictionary is immutable, so you can't modify it in your operations. This functionality is useful for experimenting with different values of a parameter without having to modify your code.</p>"},{"location":"getting-started/installation/","title":"Installing Motion","text":"<p>Motion is available on PyPI. Motion requires Python 3.8 or later. To install Motion, run the following command:</p> <pre><code>pip install motion-python\n</code></pre> <p>To verify motion is working as intended, run <code>motion</code> in your terminal. An usage explanation should be returned, as well as a list of CLI commands that can be executed.</p> <p>To install Motion with support for Applications (FastAPI apps that serve Motion components) and Tables (wrapper around PyArrow table with zero-copy vector search), run the following command:</p> <pre><code>pip install motion-python[application]\npip install motion-python[table]\n</code></pre> <p>Optionally, the shorthand <code>pip install motion-python[application,table]</code> or <code>pip install motion-python[all]</code> can be used.</p>"},{"location":"getting-started/installation/#setting-up-the-database","title":"Setting up the database","text":"<p>Motion relies on Redis to store component state and metadata. You can install Redis here and run it however you like, e.g., via Docker. You will need to configure the following environment variables:</p> <ul> <li><code>MOTION_REDIS_HOST</code>: The host of the Redis server. Defaults to <code>localhost</code>.</li> <li><code>MOTION_REDIS_PORT</code>: The port of the Redis server. Defaults to <code>6379</code>.</li> <li><code>MOTION_REDIS_PASSWORD</code>: The password of the Redis server. Defaults to <code>None</code>.</li> <li><code>MOTION_REDIS_DB</code>: The database of the Redis server. Defaults to <code>0</code>.</li> </ul>"},{"location":"getting-started/installation/#optional-installing-from-source","title":"(Optional) Installing from source","text":"<p>Motion is developed and maintained on Github. We use <code>poetry</code> to manage dependencies and build the package. To install Motion from source, run the following commands:</p> <pre><code>git clone https://github.com/dm4ml/motion\ncd motion\nmake install\n</code></pre>"},{"location":"getting-started/installation/#optional-component-visualization-tool","title":"(Optional) Component Visualization Tool","text":"<p>Check out the component visualization tool here.</p>"},{"location":"tools/cli/","title":"Component Instance CLI Utils","text":""},{"location":"tools/cli/#motion-clear","title":"<code>motion clear</code>","text":"<p>To easily clear a component instance, you can use the CLI command <code>motion clear</code>. If you type <code>motion clear --help</code>, you will see the following:</p> <pre><code>$ motion clear --help\nUsage: motion clear [OPTIONS] INSTANCE\n\n  Clears the state and cached results for a component instance.\n\n  Args:     instance (str): Instance name of the component to clear.\n  In the form `componentname__instancename`.\n\nOptions:\n  --help  Show this message and exit.\n\n  Example usage: motion clear MyComponent__myinstance\n</code></pre>"},{"location":"tools/cli/#motion-inspect","title":"<code>motion inspect</code>","text":"<p>To easily view the state stored for a component instance, you can use the CLI command <code>motion inspect</code>. If you type <code>motion inspect --help</code>, you will see the following:</p> <pre><code>$ motion inspect --help\nUsage: motion inspect [OPTIONS] INSTANCE\n\n  Prints the saved state for a component instance. Does not apply any\n  loadState() transformations.\n\n  Args:     instance (str): Instance name of the component to clear.\n  In the form `componentname__instancename`.\n\nOptions:\n  --help  Show this message and exit.\n\n  Example usage: motion inspect MyComponent__myinstance\n</code></pre>"},{"location":"tools/cli/#python-documentation","title":"Python Documentation","text":""},{"location":"tools/cli/#motion.utils.clear_instance","title":"<code>clear_instance(instance_name: str) -&gt; bool</code>","text":"<p>Clears the state and cached results associated with a component instance.</p> <p>Usage: <pre><code>from motion import clear_instance\n\nclear_instance(\"Counter__default\")\n</code></pre></p> <p>Parameters:</p> Name Type Description Default <code>instance_name</code> <code>str</code> <p>Instance name of the component to clear. In the form <code>componentname__instanceid</code>.</p> required <p>Raises:</p> Type Description <code>ValueError</code> <p>If the instance name is not in the form <code>componentname__instanceid</code>.</p> <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>True if the instance existed, False otherwise.</p>"},{"location":"tools/cli/#motion.utils.inspect_state","title":"<code>inspect_state(instance_name: str) -&gt; Optional[State]</code>","text":"<p>Returns the state of a component instance.</p> <p>Usage: <pre><code>from motion import inspect_state\n\ninspect_state(\"Counter__default\")\n</code></pre></p> <p>Parameters:</p> Name Type Description Default <code>instance_name</code> <code>str</code> <p>Instance name of the component to inspect. In the form <code>componentname__instanceid</code>.</p> required <p>Raises:</p> Type Description <code>ValueError</code> <p>If the instance name is not in the form <code>componentname__instanceid</code> or if the instance does not exist.</p> <p>Returns:</p> Name Type Description <code>State</code> <code>Optional[State]</code> <p>The state of the component instance.</p>"},{"location":"tools/dashboard/","title":"Component Dashboard","text":"<p>The dashboard is a web app that allows you to inspect and edit the states of your component instances. It is built with React and served with FastAPI.</p>"},{"location":"tools/dashboard/#running-the-dashboard","title":"Running the Dashboard","text":"<p>The dashboard is exposed as a FastAPI app, available via importing <code>motion.dashboard</code>. For example, to run the dashboard on <code>localhost:8000</code>, you can run the following code:</p> <pre><code>from motion.dashboard import dashboard_app\n\nif __name__ == \"__main__\":\n    import uvicorn\n    uvicorn.run(dashboard_app)\n</code></pre> <p>You can serve or deploy the dashboard app in any way you would serve a FastAPI app.</p>"},{"location":"tools/dashboard/#using-the-dashboard","title":"Using the Dashboard","text":"<p>The dashboard allows you to inspect component states and edit state key-value pairs. You can only edit key-value pairs with string, int, float, bool, list, or dict values. The dashboard does not support editing more complex types like numpy arrays or pandas dataframes, but you can still inspect these types.</p>"},{"location":"tools/dashboard/#victoriametrics-integration","title":"VictoriaMetrics Integration","text":"<p>The dashboard also integrates with VictoriaMetrics, a time-series database. If you have a VictoriaMetrics instance running, you can configure Motion to log flow runs and visualize flow status in the dashboard. To do this, you can set the <code>MOTION_VICTORIAMETRICS_URL</code> environment variable to the URL of your VictoriaMetrics instance. For example, to use a VictoriaMetrics instance running on <code>localhost:8428</code>, you can add the following line to your .motionrc.yml file:</p> <pre><code>MOTION_VICTORIAMETRICS_URL: \"http://localhost:8428\"\n</code></pre>"},{"location":"tools/migrator/","title":"State Migrator Tool","text":"<p>Motion provides the <code>StateMigrator</code>. to migrate the state for all instances of a component, given a migration function that takes the old state and returns the new state.</p>"},{"location":"tools/migrator/#usage","title":"Usage","text":"<p>The <code>StateMigrator</code> is a class that is initialized with a component and migration function. The migration function must have only one argument representing the state of a component instance, and must return a dictionary that replaces the state for that component instance. The migration function is applied to each component instance's state.</p> <p>This code snippet shows how to use the <code>StateMigrator</code> to add a new key to the state of all instances of a component. The migrator is run with a pool of 4 workers.</p> <pre><code>from motion import Component, StateMigrator\n\n# Create a component with a state with one key\nSomething = Component(\"Something\")\n\n\n@Something.init_state\ndef setup():\n    return {\"state_val\": 0}\n\n# Create a migration function that adds a new key to the state\ndef my_migrate_func(state):\n    state.update({\"another_val\": 0})\n    return state\n\nif __name__ == \"__main__\":\n    # Create a StateMigrator with the component and migration function\n    sm = StateMigrator(Something, my_migrate_func)\n\n    # Migrate the state for all instances of the component using a pool of 4 workers\n    results = sm.migrate(num_workers=4)\n\n    # See if there were any exceptions\n    for result in results:\n        if result.exception is not None:\n            print(f\"Exception for instance {result.instance_id}: {result.exception}\")\n</code></pre> <p>If you want to migrate the state for a single component instance, you can pass in the instance IDs of the component instances to migrate:</p> <pre><code>results = sm.migrate(instance_ids=[...], num_workers=4)\n</code></pre>"},{"location":"tools/vis/","title":"Component Visualization Tool","text":"<p>We have developed a tool to visualize the structure of a Motion component. The tool is available here.</p>"},{"location":"tools/vis/#usage","title":"Usage","text":"<p>To get a Motion component file, you should run the CLI tool in the repository with your Motion component:</p> <pre><code>$ motion vis &lt;filename&gt;:&lt;component_object&gt;\n</code></pre> <p>For example, if I had a file called <code>main.py</code> like this:</p> <pre><code>from motion import Component\n\nZScoreComponent = Component(\"ZScore\")\n\n\n@ZScoreComponent.init_state\ndef setUp():\n    return {\"mean\": None, \"std\": None, \"values\": []}\n\n\n@ZScoreComponent.serve(\"number\")\ndef serve(state, props):  # (1)!\n    if state[\"mean\"] is None:\n        return None\n    return abs(props[\"value\"] - state[\"mean\"]) / state[\"std\"]\n\n\n@ZScoreComponent.update(\"number\")\ndef update(state, props):  # (2)!\n    # Result of the serve op can be accessed via\n    # props.serve_result\n    # We don't do anything with the results, but we could!\n    value_list = state[\"values\"]\n    value_list.append(props[\"value\"])\n\n    mean = sum(value_list) / len(value_list)\n    std = sum((n - mean) ** 2 for n in value_list) / len(value_list)\n    return {\"mean\": mean, \"std\": std, \"values\": value_list}\n</code></pre> <p>I would run the CLI tool like this:</p> <pre><code>$ motion vis main.py:ZScoreComponent\n</code></pre> <p>This will generate and save a JSON file to the current directory. You can then upload this file to the vis tool visualize the component.</p>"},{"location":"tools/vis/#cli-documentation","title":"CLI Documentation","text":"<p>Running <code>motion vis --help</code> will show the following:</p> <pre><code>$ motion vis --help\nUsage: motion vis [OPTIONS] FILENAME\n\n  Visualize a component.\n\nOptions:\n  --output TEXT  JSON filename to output the component graph to.\n  --help         Show this message and exit.\n\n  Example usage: motion vis main.py:MyComponent\n</code></pre>"}]}